// Generated by CoffeeScript 1.4.0
(function() {
  var DBI, Runtime, filelet, fs, funclet, loglet, path, pathName, readdir, semver, _;

  loglet = require('loglet');

  filelet = require('filelet');

  DBI = require('easydbi');

  require('easydbi-pg');

  path = require('path');

  fs = require('fs');

  funclet = require('funclet');

  _ = require('underscore');

  semver = require('semver');

  pathName = function(filePath) {
    return path.basename(filePath, path.extname(filePath));
  };

  readdir = function(dirPath, cb) {
    return fs.readdir(dirPath, function(err, files) {
      var fileList;
      if (err) {
        return cb(err);
      } else {
        fileList = [];
        return funclet.each(files, function(file, next) {
          var filePath;
          filePath = path.join(dirPath, file);
          return fs.stat(filePath, function(err, stat) {
            if (err) {
              return next(err);
            } else if (stat.isFile() && semver.valid(path.basename(file, path.extname(file)))) {
              fileList.push(filePath);
              return next(null);
            } else {
              return next(null);
            }
          });
        })["catch"](cb).done(function(files) {
          fileList.sort(function(v1, v2) {
            return semver.compare(pathName(v1), pathName(v2));
          });
          return cb(null, fileList);
        });
      }
    });
  };

  Runtime = (function() {

    function Runtime() {
      this.conns = {};
    }

    Runtime.prototype.connect = function(key, cb) {
      var _this = this;
      if (this.conns.hasOwnProperty(key)) {
        return cb(null);
      } else {
        return DBI.connect(key, function(err, conn) {
          if (err) {
            return cb(err);
          } else {
            _this.conns[key] = conn;
            _this.current = conn;
            return cb(null);
          }
        });
      }
    };

    Runtime.prototype["eval"] = function(cmd, args, cb) {
      if (arguments.length === 2) {
        cb = args;
        args = {};
      }
      if (!this.current) {
        return cb({
          error: 'no_connection_selected',
          description: 'use :show setups to see the connections or :setup to setup one up.'
        });
      } else {
        return this.current.query(cmd, args, function(err, rows) {
          if (err) {
            return cb(err);
          } else {
            return cb(null, rows);
          }
        });
      }
    };

    Runtime.prototype.showTables = function(cb) {
      var query;
      query = "select table_name from information_schema.tables where table_schema='public' and table_type='BASE TABLE';";
      return this["eval"](query, cb);
    };

    Runtime.prototype.showColumns = function(tableName, cb) {
      var query;
      query = "select column_name, data_type, is_nullable from informatioN_schema.columns where table_schema='public' and table_name='" + tableName + "'";
      return this["eval"](query, cb);
    };

    Runtime.prototype.loadScript = function(filePath, cb) {
      var _this = this;
      return fs.readFile(filePath, 'utf8', function(err, data) {
        var item, queries;
        if (err) {
          return cb(err);
        } else {
          queries = _.filter((function() {
            var _i, _len, _ref, _results;
            _ref = data.split(/;/);
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              item = _ref[_i];
              _results.push(item.trim());
            }
            return _results;
          })(), function(q) {
            return (q != null ? q.length : void 0) > 0;
          });
          return funclet.eachSeries(queries, function(query, next) {
            loglet.log(query);
            return _this["eval"](query, function(err, rows) {
              if (err) {
                return next(err);
              } else {
                if (rows) {
                  loglet.log(rows);
                }
                return next(null);
              }
            });
          })["catch"](function(err) {
            return cb(err);
          }).done(function() {
            return cb(null);
          });
        }
      });
    };

    Runtime.prototype.deploy = function(moduleName, dirPath, cb) {
      var _this = this;
      return funclet.bind(readdir, dirPath).thenEachSeries(function(filePath, next) {
        return _this._deployScript(moduleName, filePath, next);
      })["catch"](cb).done(cb);
    };

    Runtime.prototype._deployScript = function(moduleName, filePath, cb) {
      var version,
        _this = this;
      version = path.basename(filePath, path.extname(filePath));
      return funclet.start(function(next) {
        return _this.showColumns('__version_t', function(err, columns) {
          var query;
          if (err) {
            return next(err);
          } else if (columns.length === 0) {
            query = "create table __version_t ( id serial primary key , module varchar(32) not null, version varchar(64) not null, query text not null )";
            return _this["eval"](query, function(err) {
              if (err) {
                return next(err);
              } else {
                return next(null);
              }
            });
          } else {
            return next(null);
          }
        });
      }).then(function(next) {
        return _this["eval"]('select * from __version_t where module = $module and version = $version', {
          module: moduleName,
          version: version
        }, function(err, rows) {
          if (err) {
            return next(err);
          } else if (rows.length > 0) {
            loglet.log("" + moduleName + "@" + version + " already deployed. Skip.");
            return next(null);
          } else {
            loglet.log("install " + moduleName + "@" + version + "...");
            return _this._deployScriptHelper(moduleName, version, filePath, next);
          }
        });
      })["catch"](cb).done(function() {
        return cb(null);
      });
    };

    Runtime.prototype._deployScriptHelper = function(module, version, filePath, cb) {
      var _this = this;
      return fs.readFile(filePath, 'utf8', function(err, data) {
        var item, queries;
        if (err) {
          return cb(err);
        } else {
          queries = _.filter((function() {
            var _i, _len, _ref, _results;
            _ref = data.split(/;/);
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              item = _ref[_i];
              _results.push(item.trim());
            }
            return _results;
          })(), function(q) {
            return (q != null ? q.length : void 0) > 0;
          });
          return funclet.eachSeries(queries, function(query, next) {
            loglet.log(query);
            return _this._deployEval(module, version, query, function(err, rows) {
              if (err) {
                return next(err);
              } else {
                if (rows) {
                  loglet.log(rows);
                }
                return next(null);
              }
            });
          })["catch"](function(err) {
            return cb(err);
          }).done(function() {
            return cb(null);
          });
        }
      });
    };

    Runtime.prototype._deployEval = function(module, version, query, cb) {
      var _this = this;
      return funclet.start(function(next) {
        return _this["eval"](query, function(err) {
          if (err) {
            return next(err);
          } else {
            return next(null);
          }
        });
      })["catch"](cb).done(function() {
        return _this["eval"]('insert into __version_t (module, version, query) values ($module, $version, $query)', {
          module: module,
          version: version,
          query: query
        }, cb);
      });
    };

    Runtime.prototype.exit = function(cb) {
      var conns, key, val, _ref;
      conns = [];
      _ref = this.conns;
      for (key in _ref) {
        val = _ref[key];
        conns.push(val);
      }
      return funclet.each(conns, function(conn, next) {
        return conn.disconnect(next);
      })["catch"](function(err) {
        return cb(err);
      }).done(function() {
        loglet.log('all connect disconnected.');
        return cb(null);
      });
    };

    return Runtime;

  })();

  module.exports = Runtime;

}).call(this);
