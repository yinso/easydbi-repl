// Generated by CoffeeScript 1.4.0
(function() {
  var History, Runtime, Setup, cmdParser, cmdString, coffee, funclet, history, loglet, myEval, path, repl, replExit, run, runCommand, runtime, setup, startRepl;

  repl = require('repl');

  loglet = require('loglet');

  funclet = require('funclet');

  repl = require('repl');

  path = require('path');

  coffee = require('coffee-script');

  cmdParser = require('./command');

  Runtime = require('./runtime');

  History = require('./history');

  Setup = require('./setup');

  history = History.make();

  setup = Setup.make();

  runtime = new Runtime();

  cmdString = function(cmd) {
    return cmd.substring(1, cmd.length - 2);
  };

  runCommand = function(cmd, cb) {
    var query, tableName;
    switch (cmd.command) {
      case 'setup':
        try {
          setup.setup(cmd.args[0], {
            type: cmd.args[1],
            options: cmd.args[2]
          });
          return cb(null);
        } catch (e) {
          return cb(e);
        }
        break;
      case 'use':
        return runtime.connect(cmd.args[0], cb);
      case 'show':
        switch (cmd.args[0]) {
          case 'setups':
            try {
              return cb(null, setup.showSetups());
            } catch (e) {
              return cb(e);
            }
            break;
          case 'tables':
            query = "select table_name from information_schema.tables where table_schema='public' and table_type='BASE TABLE';";
            return runtime["eval"](query, cb);
          case 'columns':
            tableName = cmd.args[1];
            query = "select column_name, data_type, is_nullable from informatioN_schema.columns where table_schema='public' and table_name='" + tableName + "'";
            return runtime["eval"](query, cb);
          default:
            return cb({
              erro: 'unknown_show_argument',
              command: cmd.command,
              args: cmd.args
            });
        }
        break;
      case 'load':
        return runtime.loadScript(cmd.args[0], cb);
      default:
        return cb({
          error: 'unknown_command',
          command: cmd.command,
          args: cmd.args
        });
    }
  };

  myEval = function(cmd, context, filename, cb) {
    var parsed, stmt;
    stmt = cmdString(cmd);
    if (stmt === '') {
      return cb(null);
    } else if (stmt.match(/^\:/)) {
      stmt = stmt.substring(1);
      try {
        parsed = cmdParser.parse(stmt);
        return runCommand(parsed, function(err, res) {
          if (err) {
            loglet.error(err);
            return cb(null);
          } else {
            return cb(null, res);
          }
        });
      } catch (e) {
        loglet.error(e);
        return cb(null);
      }
    } else {
      return runtime["eval"](stmt, function(err, res) {
        if (err) {
          loglet.error(err);
          return cb(null);
        } else {
          history.log(stmt);
          return cb(null, res);
        }
      });
    }
  };

  replExit = function() {
    loglet.log('exiting...');
    return funclet.start(function(next) {
      return history.save(next);
    }).then(function(next) {
      return setup.save(next);
    })["catch"](function(err) {
      return runtime.exit(function(err) {
        return process.exit();
      });
    }).done(function() {
      return runtime.exit(function(err) {
        return process.exit();
      });
    });
  };

  startRepl = function() {
    var inst;
    inst = repl.start({
      prompt: 'dbi> ',
      input: process.stdin,
      output: process.stdout,
      "eval": myEval
    });
    inst.on('exit', replExit);
    return history.bind(inst);
  };

  run = function(argv) {
    return funclet.start(function(next) {
      return setup.load(next);
    }).then(function(next) {
      return history.load(next);
    })["catch"](function(err) {
      return loglet.croak(err);
    }).done(function() {
      return startRepl();
    });
  };

  module.exports = {
    run: run
  };

}).call(this);
